//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Lucene.Net.Search;
using NHibernate.Engine;
using NHibernate.Engine.Query;
using NHibernate.Impl;
using NHibernate.Search.Engine;
using NHibernate.Search.Impl;
using NHibernate.Search.Util;
using NHibernate.Util;

namespace NHibernate.Search.Query
{
    using Filter;

    using Transform;
    using System.Threading.Tasks;
    using System.Threading;

    public partial class FullTextQueryImpl : QueryImpl, IFullTextQuery
    {

        #region Constructors

        #endregion

        /// <summary>
        /// Return an interator on the results.
        /// Retrieve the object one by one (initialize it during the next() operation)
        /// </summary>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
        public override async Task<IEnumerable<T>> EnumerableAsync<T>(CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SessionIdLoggingContext.CreateOrNull(Session.SessionId))
            {
                //implement an interator which keep the id/class for each hit and get the object on demand
                //cause I can't keep the searcher and hence the hit opened. I dont have any hook to know when the
                //user stop using it
                //scrollable is better in this area

                //find the directories
                IndexSearcher searcher = BuildSearcher();
                if (searcher == null)
                {
                    return await (new IteratorImpl<T>(new List<EntityInfo>(), noLoader).IterateAsync(cancellationToken));
                }

                try
                {
                    TopDocs topDocs = GetTopDocs(searcher);
                    SetResultSize(topDocs);
                    int first = First();
                    int max = Max(first, topDocs);

                    int size = max - first + 1 < 0 ? 0 : max - first + 1;
                    IList<EntityInfo> infos = new List<EntityInfo>(size);
                    DocumentExtractor extractor = new DocumentExtractor(SearchFactory, indexProjection);
                    for (int index = first; index <= max; index++)
                    {
                        //TODO use indexSearcher.getIndexReader().document( hits.id(index), FieldSelector(indexProjection) );
                        infos.Add(extractor.Extract(topDocs, searcher, index));
                    }
                    return await (new IteratorImpl<T>(infos, this.GetLoader((ISession)Session)).IterateAsync(cancellationToken));
                }
                catch (IOException e)
                {
                    throw new HibernateException("Unable to query Lucene index", e);
                }
                finally
                {
                    CloseSearcher(searcher);
                }
            }
        }

        public override async Task<IEnumerable> EnumerableAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SessionIdLoggingContext.CreateOrNull(Session.SessionId))
            {
                return await (EnumerableAsync<object>(cancellationToken));
            }
        }

        public override async Task<IList<T>> ListAsync<T>(CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SessionIdLoggingContext.CreateOrNull(Session.SessionId))
            {
                ArrayList arrayList = new ArrayList();
                await (ListAsync(arrayList, cancellationToken));
                return (T[])arrayList.ToArray(typeof(T));
            }
        }

        //protected override IEnumerable<ITranslator> GetTranslators(ISessionImplementor sessionImplementor, QueryParameters queryParameters)
        //{
        //    throw new NotImplementedException();
        //}

        public override async Task<IList> ListAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SessionIdLoggingContext.CreateOrNull(Session.SessionId))
            {
                ArrayList arrayList = new ArrayList();
                await (ListAsync(arrayList, cancellationToken));
                return arrayList;
            }
        }

        public override async Task ListAsync(IList list, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SessionIdLoggingContext.CreateOrNull(Session.SessionId))
            {
                // Find the directories
                IndexSearcher searcher = BuildSearcher();
                if (searcher == null)
                {
                    return;
                }

                try
                {
                    TopDocs topDocs = GetTopDocs(searcher);
                    SetResultSize(topDocs);
                    int first = First();
                    int max = Max(first, topDocs);
                    int size = max - first + 1;
                    if (size <= 0)
                    {
                        return;
                    }

                    ISession sess = (ISession)Session;
                    List<EntityInfo> infos = new List<EntityInfo>(size);
                    DocumentExtractor extractor = new DocumentExtractor(SearchFactory, indexProjection);
                    for (int index = first; index <= max; index++)
                    {
                        infos.Add(extractor.Extract(topDocs, searcher, index));
                    }

                    ILoader loader = GetLoader(sess);
                    IList entities = await (loader.LoadAsync(infos.ToArray(), cancellationToken));
                    foreach (object entity in entities)
                    {
                        list.Add(entity);
                    }

                    if (entities.Count != infos.Count)
                        log.Warn("Lucene index contains infos about " + infos.Count + " entities, but " + entities.Count +
                                 " were found in the database. Rebuild the index.");

                    if (resultTransformer == null || loader is ProjectionLoader)
                    {
                        // stay consistent with transformTuple which can only be executed during a projection
                    }
                    else
                    {
                        IList tempList = resultTransformer.TransformList(list);
                        list.Clear();
                        foreach (object entity in tempList)
                        {
                            list.Add(entity);
                        }
                    }

                }
                catch (IOException e)
                {
                    throw new HibernateException("Unable to query Lucene index", e);
                }
                finally
                {
                    CloseSearcher(searcher);
                }
            }
        }

        public override Task<int> ExecuteUpdateAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            throw new HibernateException("Not supported operation");
        }

        #region Nested type: NoLoader

        private partial class NoLoader : ILoader
        {

            public Task<object> LoadAsync(EntityInfo entityInfo, CancellationToken cancellationToken = default(CancellationToken))
            {
                throw new NotSupportedException("noLoader should not be used");
            }

            public Task<IList> LoadAsync(EntityInfo[] entityInfos, CancellationToken cancellationToken = default(CancellationToken))
            {
                throw new NotSupportedException("noLoader should not be used");
            }
        };

        #endregion

        #region Nested type: IteratorImpl

        private partial class IteratorImpl<T>
        {

            public async Task<IEnumerable<T>> IterateAsync(CancellationToken cancellationToken = default(CancellationToken))
            {
                cancellationToken.ThrowIfCancellationRequested();
                var yields = new List<T>();
                foreach (EntityInfo entityInfo in entityInfos)
                    yields.Add((T)await (loader.LoadAsync(entityInfo, cancellationToken)));
                return yields;
            }
        }

        #endregion
    }
}